<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>判断字符串包含方法</title>
      <link href="/2021/08/31/wu-xiu-xiao-ji/"/>
      <url>/2021/08/31/wu-xiu-xiao-ji/</url>
      
        <content type="html"><![CDATA[<p><strong>看过的越来越多，杂而不纯。</strong></p><p>前端也开始卷起来了，晚上逛B站推的也是各种前端课程，偶然间看到不会的知识点会有些许慌张，先换家公司看看，接触一些新技术，尝试一些新方向。</p><p> 加油！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echarts配置项</title>
      <link href="/2021/08/25/echarts-pei-zhi-xiang/"/>
      <url>/2021/08/25/echarts-pei-zhi-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Echarts-配置项"><a href="#Echarts-配置项" class="headerlink" title="Echarts 配置项"></a>Echarts 配置项</h1><h2 id="X轴文字显示"><a href="#X轴文字显示" class="headerlink" title="X轴文字显示"></a>X轴文字显示</h2><ul><li><p>竖着显示</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">xAxis ： <span class="token punctuation">{</span>             axisLabel<span class="token punctuation">:</span><span class="token punctuation">{</span>                  interval<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                  <span class="token named-parameter punctuation">formatter</span><span class="token punctuation">:</span> function <span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">//x轴的文字改为竖版显示</span>                    <span class="token class-name"><span class="token keyword">var</span></span> str <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token keyword">join</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>倾斜45度数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">xAixs <span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token comment">// x轴文字倾斜</span>                   <span class="token comment">// x轴文字倾斜</span>                axisLabel<span class="token operator">:</span><span class="token punctuation">{</span>                  interval<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>                  rotate<span class="token operator">:</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token comment">//倾斜度 -90 至 90 默认为0</span>                  margin<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>                  textStyle<span class="token operator">:</span><span class="token punctuation">{</span>                    fontWeight<span class="token operator">:</span><span class="token string">"bolder"</span><span class="token punctuation">,</span>                    color<span class="token operator">:</span><span class="token string">"#000000"</span>                  <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>X 轴数据太多折叠显示</p><pre class="line-numbers language-none"><code class="language-none">axisLabel: {interval: 0,formatter(value) {if (value.length &gt; 5) {value = `${value.substring(0, 5)}..`;}return value;}},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>饼图legend太多显示 </p><pre class="line-numbers language-none"><code class="language-none">// formatter(name) {//     return (name.length &gt; 5 ? (`${name.slice(0, 5)}...`) : name); // }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="动态给的Echarts高度"><a href="#动态给的Echarts高度" class="headerlink" title="动态给的Echarts高度"></a>动态给的Echarts高度</h2><pre class="line-numbers language-none"><code class="language-none">autodivheight() { // 函数：获取尺寸​            // 获取浏览器窗口高度​            let winHeight = 0;​            if (window.innerHeight) {​                winHeight = window.innerHeight;​            } else if ((document.body) &amp;&amp; (document.body.clientHeight)) {​                winHeight = document.body.clientHeight;​            }​            // 通过深入Document内部对body进行检测，获取浏览器窗口高度​            if (document.documentElement &amp;&amp; document.documentElement.clientHeight) {​                winHeight = document.documentElement.clientHeight;​            }​            // DIV高度为浏览器窗口的高度​            // document.getElementById("test").style.height= winHeight +"px";​            // DIV高度为浏览器窗口高度的一半​            document.getElementById('chart').style.height = `${winHeight * 0.6}px`;​        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化图表"><a href="#初始化图表" class="headerlink" title="初始化图表"></a>初始化图表</h2><pre class="line-numbers language-none"><code class="language-none">myChart.clear();myChart.setOption(this.option); window.onresize = () =&gt; {this.autodivheight(); //  根据窗口大小调整曲线大小myChart.resize();};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="x轴name的位置"><a href="#x轴name的位置" class="headerlink" title="x轴name的位置"></a>x轴name的位置</h2><pre class="line-numbers language-none"><code class="language-none">xAxis: {              name: '报表日',              type: 'category',              axisLabel: {                  interval: 0              }, // x轴显示完整              nameTextStyle: {                  padding: [0, 0, 0, 20] // 四个数字分别为上右下左与原位置距离              },              data: []          },<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Y轴的网格线的配置"><a href="#Y轴的网格线的配置" class="headerlink" title="Y轴的网格线的配置"></a>Y轴的网格线的配置</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">yAxis<span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                type<span class="token operator">:</span> <span class="token string">'value'</span><span class="token punctuation">,</span>                name<span class="token operator">:</span> <span class="token string">'企业数'</span>             <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                type<span class="token operator">:</span> <span class="token string">'value'</span><span class="token punctuation">,</span>                name<span class="token operator">:</span> <span class="token string">'提交率（%）'</span><span class="token punctuation">,</span>                min<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                max<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>                interval<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>                offset<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                axisLabel<span class="token operator">:</span> <span class="token punctuation">{</span>                    formatter<span class="token operator">:</span> <span class="token string">'{value} %'</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                splitLine<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// 网格线</span>                    show<span class="token operator">:</span> <span class="token boolean">false</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工具栏的配置"><a href="#工具栏的配置" class="headerlink" title="工具栏的配置"></a>工具栏的配置</h2><pre class="line-numbers language-none"><code class="language-none">toolbox: {             right: '-5px',             top: '-10px',             backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色             borderColor: '#ccc', // 工具箱边框颜色             borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框）             padding: 15, // 工具箱内边距，单位px，默认各方向内边距为5，             // 接受数组分别设定上右下左边距，同css             itemGap: 10, // 各个item之间的间隔，单位px，默认为10，             // 横向布局时为水平间隔，纵向布局时为纵向间隔             itemSize: 16,               feature: {                 magicType: {                      show: true,                     barWidth: 30,                     type: ['bar', 'line'],                     title: {                         line: '折线图',                         bar: '柱状图'                     }                 },                 restore: { show: true }             }         },<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js运算符优先级</title>
      <link href="/2021/08/25/js-yun-suan-fu-you-xian-ji/"/>
      <url>/2021/08/25/js-yun-suan-fu-you-xian-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="JS运算符优先级"><a href="#JS运算符优先级" class="headerlink" title="JS运算符优先级"></a>JS运算符优先级</h1><h2 id="js运算符"><a href="#js运算符" class="headerlink" title="js运算符"></a>js运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><pre class="line-numbers language-none"><code class="language-none">+ - * /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>运算顺序：先算乘除取余、再算加减，有小括号先算小括号。</p></li><li><p>NaN 参与的运算 :得到结果都为NaN；</p></li><li><p>infinity 参与的运算 ：视情况而定。</p></li><li><p>“+” 参与视情况隐式转换。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3></li><li><p>比较运算符</p></li><li><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>==</code></td><td>相等 <code>只判断值大小是否相等</code>，<code>不判断数据类型</code></td></tr><tr><td><code>!=</code></td><td>不等 <code>与相等完全相反</code></td></tr><tr><td><code>===</code></td><td>全等 <code>不光判断值相等</code>，<code>还要判断数据类型相等</code></td></tr><tr><td><code>!==</code></td><td>不全等 <code>与全等于完全相反</code></td></tr></tbody></table></li><li><p>NaN参与：不等于和不全等于结果是 <code>true</code>，其他的都得到 <code>false</code></p></li><li><p>Infinity参与的运算，视情况而定</p></li><li><p>其他数据类型也会隐式转换为数字参与比较。</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token string">"123"</span> → <span class="token number">123</span>        <span class="token boolean">true</span> → <span class="token number">1</span>        <span class="token boolean">false</span> → <span class="token number">0</span>        <span class="token keyword">null</span> → <span class="token number">0</span>        <span class="token keyword">undefined</span> → <span class="token number">NaN</span>        <span class="token string">""</span> → <span class="token number">0</span>        <span class="token string">"abc"</span> → <span class="token number">NaN</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>null 的判断比较特殊：null 与 0 判断时，相等判断为 false，&gt;= 和 &lt;= 判断为 true</p></li><li><p>字符串比较时，比较两个字符串的 Unicode 编码顺序。从前往后 0-9，A-Z，a-z，前面的小于后面的。不关心两个字符串的长度，从第一个字符开始比较，依次往后顺延比较，直到比较出大小，就不再往后比较。</p><pre><code>    // 字符串之间比较    console.log(3 &lt; "7"); // true    console.log("3" &lt; "17"); // false    console.log("3" &lt; "37"); // true    console.log("3" &lt; "47"); // true    console.log("3" &lt; "3"); // false    console.log("3" &lt; "a"); // true    console.log("A" &lt; "a"); // true    console.log("A" &lt; "0a"); // false    console.log("Z" &lt; "a"); // true    console.log("9Z" &lt; "a"); // true        // 比较顺序，从前往后比较，前面先得出结果再参与后面的比较    console.log(3 &gt; 2 &gt; 1);  // false  3 &gt; 2 为true,1为true，所以true&gt;true为false。</code></pre></li><li><p>转为<code>false</code>：NaN、0、“”空字符串、null、undefined</p></li><li><p>转为<code>true</code>：非0 非NaN数字、非空字符串</p></li><li><pre><code>(逻辑与 a &amp;&amp; b ) 如果a能被转换为false，那么返回a；否则，返回b。(逻辑或 a || b ) 如果a能被转换为true，那么返回a；否则，返回b。</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 选择器</title>
      <link href="/2021/08/25/ast-chou-xiang-yu-fa-shu/"/>
      <url>/2021/08/25/ast-chou-xiang-yu-fa-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Babel原理"><a href="#Babel原理" class="headerlink" title="Babel原理"></a>Babel原理</h1><h3 id="Babel的工作流程"><a href="#Babel的工作流程" class="headerlink" title="Babel的工作流程"></a>Babel的工作流程</h3><ul><li><p>解析：解析成AST，由babylon引擎实现。</p><p>两个阶段：词法分析、语法分析。</p><ul><li><p>词法分析：字符串=&gt;令牌（token）类似于ast节点。</p></li><li><p>语法分析：令牌=&gt;AST，信息=&gt;ast的方式。</p></li></ul></li><li><p>转换：接受到AST后进行处理：通过babel-traverse进行遍历，进行节点的添加、更新、移除等操作。（Babel开始介入工作）</p></li><li><p>生成：讲转换完成的AST通过babel-generator转换成js代码，进行整体遍历，然后进行转换对应的字符串。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的watch</title>
      <link href="/2021/08/25/watch-de-jian-ting/"/>
      <url>/2021/08/25/watch-de-jian-ting/</url>
      
        <content type="html"><![CDATA[<h1 id="Watch的监听"><a href="#Watch的监听" class="headerlink" title="Watch的监听"></a>Watch的监听</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;      &lt;p&gt;FullName: {{fullName}}&lt;/p&gt;      &lt;p&gt;FirstName: &lt;input type="text" v-model="firstName"&gt;&lt;/p&gt;&lt;/div&gt; new Vue({  el: '#root',  data: {    firstName: 'Dawei',    lastName: 'Lou',    fullName: ''  },  watch: {    firstName(newName, oldName) {      this.fullName = newName + ' ' + this.lastName;    }  } })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以函数的形式进行监听，个人认为是内部定义函数名===监听对象，接手（new，old）俩参数，执行对应的函数。<br>第一次不会监听，等到其值发生变化才会监听执行。</p><h2 id="初始执行watch方法"><a href="#初始执行watch方法" class="headerlink" title="初始执行watch方法"></a>初始执行watch方法</h2><pre class="line-numbers language-none"><code class="language-none">watch: {  firstName: {    handler(newName, oldName) {      this.fullName = newName + ' ' + this.lastName;    },    // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法，如果设置了false，那么效果和上边例子一样    immediate: true  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以对象的形式进行监听，内部实现 监听对象===（对象名|| 函数名），增加handler函数内部进行监听，同样接受（new,old）参数进行处理，增加immediate属性进行是否初始监听的选项。</p><h2 id="深度监听"><a href="#深度监听" class="headerlink" title="深度监听"></a>深度监听</h2><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;      &lt;p&gt;obj.a: {{obj.a}}&lt;/p&gt;      &lt;p&gt;obj.a: &lt;input type="text" v-model="obj.a"&gt;&lt;/p&gt;&lt;/div&gt; new Vue({  el: '#root',  data: {    obj: {      a: 123    }  },  watch: {    obj: {      handler(newName, oldName) {         console.log('obj.a changed');      },      immediate: true,      deep:true    }  } })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>深度，顾名思义为deep监听方法，用于对象的监听，因vue无法动态监听其对象属性的增删，其主要在初始实例时才实现getter\setter 的转换。</p><p>缺点：obj任一属性改变则会执行该函数，性能开销较大。<br>建议：改为值监听即栈。</p><pre class="line-numbers language-none"><code class="language-none">watch: {  'obj.a': {    handler(newName, oldName) {      console.log('obj.a changed');    },    immediate: true,    // deep: true  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 选择器</title>
      <link href="/2021/08/25/css-xuan-ze-qi/"/>
      <url>/2021/08/25/css-xuan-ze-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="css选择器-、-、-gt"><a href="#css选择器-、-、-gt" class="headerlink" title="css选择器+、~、>"></a><a href="https://www.cnblogs.com/weiqinl/p/9665808.html">css选择器+、~、&gt;</a></h1><p>在css中，选择器是一种模式，用于选择需要添加样式的元素。它有多种选择器，我们看一下比较常见，但容易混淆的三个选择器<code>+</code>、<code>~</code>、<code>&gt;</code></p><h2 id="A-B（相邻兄弟选择器）"><a href="#A-B（相邻兄弟选择器）" class="headerlink" title="A + B（相邻兄弟选择器）"></a>A + B（相邻兄弟选择器）</h2><p>定义：css2。 匹配B元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）。</p><h2 id="A-B-（通用兄弟选择器）"><a href="#A-B-（通用兄弟选择器）" class="headerlink" title="A ~ B （通用兄弟选择器）"></a>A ~ B （通用兄弟选择器）</h2><p>定义： css3。匹配B元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A）</p><h2 id="A-gt-B-（子选择器）"><a href="#A-gt-B-（子选择器）" class="headerlink" title="A > B （子选择器）"></a>A &gt; B （子选择器）</h2><p>定义：css2。匹配B元素，满足条件：B是A的直接子节点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map、Set</title>
      <link href="/2021/08/25/map-set/"/>
      <url>/2021/08/25/map-set/</url>
      
        <content type="html"><![CDATA[<h1 id="map、set"><a href="#map、set" class="headerlink" title="map、set"></a>map、set</h1><h2 id="set：集合"><a href="#set：集合" class="headerlink" title="set：集合"></a>set：集合</h2><p>集合 : 无序且唯一的项，类似于没有重复元素和顺序的数组。</p><p>其构造函数也为set() 故可以直接用它进行生成set数据结构。</p><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>size ：返回数量，类似数组length</p><p>add():添加<br>delete()：移除<br>has():返回布尔值，有=&gt;true<br>clear():移除集合中所有的项目(清空set)</p><p>keys():返回集合中键的数组（类似于对象）<br>values():返回集合中值的数组（类似于对象）<br>entries():返回包含键值对的数组 （对象也有该方法）<br>forEach():类数组</p><h2 id="map-字典"><a href="#map-字典" class="headerlink" title="map:字典"></a>map:字典</h2><p>字典：以key=&gt;value 的形式存储。主要存储数据，保证了值=&gt;值。</p><h3 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>size ：返回字典元素个数，类似数组length</p><p>set(key,val):添加<br>delete(key)：移除<br>has(key):返回布尔值，有=&gt;true,valueOf()<br>clear():移除集合中所有的项目(清空set)<br>get(key):查找方法</p><p>keys():返回集合中键的数组（类似于对象）<br>values():返回集合中值的数组（类似于对象）<br>forEach():类数组</p>]]></content>
      
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程化小感悟</title>
      <link href="/2021/08/25/webpack-he-vite/"/>
      <url>/2021/08/25/webpack-he-vite/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-和-vite"><a href="#webpack-和-vite" class="headerlink" title="webpack 和 vite"></a>webpack 和 vite</h1><p>1.vite 的发展确实比较好</p><p>2.取代webpack还需要较长的路：</p><ul><li><p>vue 支持vite，也支持webpack</p></li><li><p>React、Angular 目前没有支持，暂时也没有向vite的打算；</p></li><li><p>最终打包任需要rollup实现。</p></li></ul><p>3、vite思想不是首创</p><ul><li>其与snowpack是重合的，且目前snowpack较之更为成熟；</li><li>后续可能会超越</li></ul><p>4、webpack的更新迭代与项目的耦合度较高。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断小数点后几位</title>
      <link href="/2021/08/25/pan-duan-xiao-shu-dian-hou-ji-wei/"/>
      <url>/2021/08/25/pan-duan-xiao-shu-dian-hou-ji-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="判断小数点后几位"><a href="#判断小数点后几位" class="headerlink" title="判断小数点后几位"></a>判断小数点后几位</h1><pre class="line-numbers language-js" data-language="js"><code class="language-js">number<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2021/08/25/webpack-de-ji-chu-pei-zhi/"/>
      <url>/2021/08/25/webpack-de-ji-chu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack的基础配置"><a href="#webpack的基础配置" class="headerlink" title="webpack的基础配置"></a>webpack的基础配置</h1><p>1.明确一点，webpack只是工具用来构建我们的开发项目，与框架无关。</p><h2 id="cli使用webpack"><a href="#cli使用webpack" class="headerlink" title="cli使用webpack"></a>cli使用webpack</h2><p>不使用配置文件时候，可以使用全局的webpack命令，具体可查看文档配置flags</p><pre class="line-numbers language-none"><code class="language-none">webpack --entry ./first.js --entry ./second.js --output-path /build即为打包到build文件夹下，默认名为main.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="项目中使用webpack"><a href="#项目中使用webpack" class="headerlink" title="项目中使用webpack"></a>项目中使用webpack</h2><p>四个核心：entry，output，module，plugins</p><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>打包入口，可以为绝对路径也可为相对路径。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>输出模块</p><pre class="line-numbers language-none"><code class="language-none">filename: 'bundle.js', //输出文件名      // path:'./build'      path: path.resolve(__dirname, './build'), //找到绝对路径 =&gt; 拼接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>模块匹配规则，接受rules匹配规则</p><pre class="line-numbers language-none"><code class="language-none">{                // 使用正则表达式                test: /\.css$/, // 以css结尾匹配                use: [                    // UseEntry                    // {                    //     loader: 'css-loader'                       // }                    'style-loader', // 下往上 =&gt; 栈 =&gt; 先进后出                    // 'css-loader',// 简写方式 实际还是转成上述方式                    //  loader: ['css-loader']                    {                        loader: 'css-loader',                        options: {                            importLoaders: 1 //后面有几个loader则写几。                        }                    },                    'postcss-loader'                    // {                    //     loader: "postcss-loader",                    //     options: {                    //         postcssOptions: {                    //             plugins: [ //依赖多个插件                    //                 // require("autoprefixer"),                    //                 // require('postcss-preset-env') //内置autoprefixer                    //                 'postcss-preset-env' // 简写                    //             ]                    //         }                    //     }                    // }                ],                // 加载方式 创建标签=&gt; document.createElement(style) 页内样式            },<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速删除node_modules</title>
      <link href="/2021/08/25/kuai-su-shan-chu/"/>
      <url>/2021/08/25/kuai-su-shan-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="快速删除"><a href="#快速删除" class="headerlink" title="快速删除"></a>快速删除</h1><p>npm i -g rimraf</p><p>rimraf node_modules</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器进程</title>
      <link href="/2021/08/25/liu-lan-qi-jin-cheng/"/>
      <url>/2021/08/25/liu-lan-qi-jin-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h1><p><strong>chrome 为了节省内存的使用，限制了最多的进程数，最大进程数量由设备的内存和 CPU 能力决定，当达到这一限制时，新打开的 Tab 会共用之前同一个站点的渲染进程。</strong></p><h2 id="GUI-渲染进程"><a href="#GUI-渲染进程" class="headerlink" title="GUI 渲染进程"></a>GUI 渲染进程</h2><p>1、解析执行HTML文档，生成Dom树。</p><p>2、绘制CSS树。</p><h2 id="引擎进程"><a href="#引擎进程" class="headerlink" title="引擎进程"></a>引擎进程</h2><p>执行js脚本。</p><p>在浏览器渲染进程中必存在。</p><p>GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>a) 减少 JavaScript 加载对 DOM 渲染的影响（将 JavaScript 代码的加载逻辑放在 HTML 文件的尾部，减少对渲染引擎呈现工作的影响；<br>b) 避免重排，减少重绘（避免白屏，或者交互过程中的卡顿；<br>c) 减少 DOM 的层级（可以减少渲染引擎工作过程中的计算量；<br>d) 使用 requestAnimationFrame 来实现视觉变化（一般来说我们会使用 setTimeout 或 setInterval 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解构赋值</title>
      <link href="/2021/08/25/jie-gou-fu-zhi/"/>
      <url>/2021/08/25/jie-gou-fu-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><pre class="line-numbers language-none"><code class="language-none">const obj = {  name: '林三心',  age: 22,  gender: '男',  doing: {    morning: '摸鱼',    afternoon: '摸鱼',    evening: 'sleep'  }}const { name, age, gender } = objconsole.log(name, age, gender) // 林三心 22 男// 解构重名const { name: myname } = objconsole.log(myname) // 林三心// 嵌套解构const { doing: { evening } } = objconsole.log(evening) // sleep<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">数组结构const arr = [1, 2, 3]const [a, b, c] = arrconsole.log(a, b, c) // 1 2 3// 默认赋值const [a, b, c, d = 5] = arrconsole.log(a, b, c, d) // 1 2 3 5// 乱序解构const { 1: a, 0: b, 2: c } = arrconsole.log(a, b, c) // 2 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>trimStart和trimEnd用来单独去除字符串的首和尾的空格</p><pre class="line-numbers language-none"><code class="language-none">const str = '    林三心    '// 去除首部空格console.log(str.trimStart()) // '林三心   '// 去除尾部空格console.log(str.trimStart()) // '   林三心'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的数据类型概述</title>
      <link href="/2021/08/25/js-de-shu-ju-lei-xing-gai-shu/"/>
      <url>/2021/08/25/js-de-shu-ju-lei-xing-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="js的数据类型概述"><a href="#js的数据类型概述" class="headerlink" title="js的数据类型概述"></a>js的数据类型概述</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul><li><p>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）</p></li><li><p>字符串（string）：文本（比如<code>Hello World</code>）。</p></li><li><p>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）</p></li><li><p><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</p></li><li><p><code>null</code>：表示空值，即此处的值为空。</p></li><li><p>对象（object）：各种值组成的集合。</p><p>注1:</p><p>ES6新增了第七种Symbol类型”<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;%EF%BC%8C%E5%89%8D%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%A7%B0%E4%B8%BA%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"，前三种数据类型称为原始类型</a></p><p>注2:</p><p>对象可分为三个子类型(对象可以看成原始类型数据值的合成，类似于容器)</p><ul><li>狭义的对象（object）</li><li>数组（array）</li><li>函数（function）</li></ul></li></ul><h2 id="二、typeof-运算符"><a href="#二、typeof-运算符" class="headerlink" title="二、typeof 运算符"></a>二、typeof 运算符</h2><p>​        JS确定数据的基本类型有以下三种方法：</p><ul><li><p><code>typeof</code>运算符：返回一个值的数据类型</p></li><li><p><code>instanceof</code>运算符</p></li><li><p><code>Object.prototype.toString</code>方法</p><p>注：<code>typeof null </code>//“object”</p><p>原因：由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p></li></ul><h2 id="三、null-和-undefined"><a href="#三、null-和-undefined" class="headerlink" title="三、null 和 undefined"></a>三、null 和 undefined</h2><p>​        <strong>null表示”没有对象”，即该处不应该有值。</strong>典型用法是：</p><blockquote><p>（1） 作为函数的参数，表示该函数的参数不是对象。</p><p>（2） 作为对象原型链的终点。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token comment">// null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</strong>典型用法是：</p><blockquote><p>（1）变量被声明了，但没有赋值时，就等于undefined。</p><p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p><p>（3）对象没有赋值的属性，该属性的值为undefined。</p><p>（4）函数没有返回值时，默认返回undefined。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> i<span class="token punctuation">;</span>i <span class="token comment">// undefined</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span><span class="token keyword">var</span>  o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span>p <span class="token comment">// undefined</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、布尔值"><a href="#四、布尔值" class="headerlink" title="四、布尔值"></a>四、布尔值</h2><p>​        布尔值只有“true”和“false”的两个状态。</p><p>​        下列运算符会返回布尔值：</p><ul><li>前置逻辑运算符： <code>!</code> (Not)</li><li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li><li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li></ul><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p><ul><li><p><code>undefined</code></p></li><li><p><code>null</code></p></li><li><p><code>false</code></p></li><li><p><code>0</code></p></li><li><p><code>NaN</code></p></li><li><p><code>""</code>或<code>''</code>（空字符串）</p><p>注：空字符串对应布尔值false。</p><p>​        空数组、对象对应布尔值true。</p></li></ul><h2 id="五、数值"><a href="#五、数值" class="headerlink" title="五、数值"></a>五、数值</h2><p>​        JS语言的底层数字皆以64位浮点数存储。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token operator">===</span> <span class="token number">1.0</span><span class="token comment">//true</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token comment">// false</span><span class="token number">0.3</span> <span class="token operator">/</span> <span class="token number">0.1</span><span class="token comment">// 2.9999999999999996</span><span class="token punctuation">(</span><span class="token number">0.3</span> <span class="token operator">-</span> <span class="token number">0.2</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token punctuation">(</span><span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>范围：</p><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2-1024到2-1023次方（开区间），超出这个范围的数无法表示。</p><p>(0-&gt;Infinity)</p><p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p><pre class="line-numbers language-none"><code class="language-none">var x = 0.5;for(var i = 0; i &lt; 25; i++) {  x = x * x;}x// 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>特殊值：</p><p>1.正零和负零</p><p>几乎是等价的，唯一区别<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的。</p><p><code>(1 / +0) === (1 / -0) // false</code></p><p>原因：除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的。</p><p>2.NaN(Not a Number)</p><p>表示“非数字”，主要出现在将字符串解析成数字出错的场合。</p><p><code>NaN</code>不等于任何值，包括它本身。</p><p><code>NaN === NaN </code>  //false</p><p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p><p><code>[NaN].indexOf(NaN) // -1</code></p><p><code>NaN</code>在布尔运算时被当作<code>false</code>。</p><p><code>Boolean(NaN) // false</code></p><p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p><pre class="line-numbers language-none"><code class="language-none">NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.Infinity</p><p>1.表示无穷。数值太大或太小无法表示，另一种是非0数值除以0，得到Infinity。</p><pre class="line-numbers language-none"><code class="language-none">// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.Infinity有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷。</p><p>3.<code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）。</p><p>4.<code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。</p><p>4.方法：</p></li></ul><h3 id="1-parseInt"><a href="#1-parseInt" class="headerlink" title="1.parseInt()"></a>1.parseInt()</h3><p>将字符串转为数值。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('123') // 123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果字符串头部有空格，空格会被自动去除。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('   81') // 81<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p><pre class="line-numbers language-none"><code class="language-none">parseInt(1.23) // 1// 等同于parseInt('1.23') // 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('8a') // 8parseInt('12**') // 12parseInt('12.34') // 12parseInt('15e2') // 15parseInt('15px') // 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('abc') // NaNparseInt('.3') // NaNparseInt('') // NaNparseInt('+') // NaNparseInt('+1') // 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p><p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('0x10') // 16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果字符串以<code>0</code>开头，将其按照10进制解析。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('011') // 11<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p><pre class="line-numbers language-none"><code class="language-none">parseInt(1000000000000000000000.5) // 1// 等同于parseInt('1e+21') // 1parseInt(0.0000008) // 8// 等同于parseInt('8e-7') // 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）进制转换</strong></p><p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('1000') // 1000// 等同于parseInt('1000', 10) // 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面是转换指定进制的数的例子。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 8</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token comment">// 216</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1000'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token comment">// 512</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('10', 37) // NaNparseInt('10', 1) // NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p><pre class="line-numbers language-none"><code class="language-none">parseInt('1546', 2) // 1parseInt('546', 2) // NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面代码中，对于二进制来说，<code>1</code>是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code>都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>。</p><p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><pre class="line-numbers language-none"><code class="language-none">parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt('17', 36)parseInt('17', 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</p><p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p><pre class="line-numbers language-none"><code class="language-none">parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt('011', 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h3 id="2-parseFloat"><a href="#2-parseFloat" class="headerlink" title="2.parseFloat()"></a>2.parseFloat()</h3><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p><pre class="line-numbers language-none"><code class="language-none">parseFloat('3.14') // 3.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果字符串符合科学计数法，则会进行相应的转换。</p><pre class="line-numbers language-none"><code class="language-none">parseFloat('314e-2') // 3.14parseFloat('0.0314E+2') // 3.14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><pre class="line-numbers language-none"><code class="language-none">parseFloat('3.14more non-digit characters') // 3.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p><pre class="line-numbers language-none"><code class="language-none">parseFloat('\t\v\r12.34\n ') // 12.34<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p><pre class="line-numbers language-none"><code class="language-none">parseFloat([]) // NaNparseFloat('FF2') // NaNparseFloat('') // NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p><pre class="line-numbers language-none"><code class="language-none">parseFloat(true)  // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat('') // NaNNumber('') // 0parseFloat('123.45#') // 123.45Number('123.45#') // NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-isNaN"><a href="#3-isNaN" class="headerlink" title="3.isNaN()"></a>3.isNaN()</h3><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p><pre class="line-numbers language-none"><code class="language-none">isNaN(NaN) // trueisNaN(123) // false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p><pre class="line-numbers language-none"><code class="language-none">isNaN('Hello') // true// 相当于isNaN(Number('Hello')) // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p><pre class="line-numbers language-none"><code class="language-none">isNaN({}) // true// 等同于isNaN(Number({})) // trueisNaN(['xzy']) // true// 等同于isNaN(Number(['xzy'])) // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p><pre class="line-numbers language-none"><code class="language-none">isNaN([]) // falseisNaN([123]) // falseisNaN(['123']) // false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p><p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p><pre class="line-numbers language-none"><code class="language-none">function myIsNaN(value) {  return typeof value === 'number' &amp;&amp; isNaN(value);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p><pre class="line-numbers language-none"><code class="language-none">function myIsNaN(value) {  return value !== value;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-isFinite"><a href="#4-isFinite" class="headerlink" title="4.isFinite()"></a>4.isFinite()</h3><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><pre class="line-numbers language-none"><code class="language-none">isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p><h2 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h2><p>​        1.定义：</p><p>​        零个或多个排在一起的字符，放在单引号或多引号之中。单双引号可以在内部相互使用。</p><p>​        如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">'Did she say \'Hello\'?'</span><span class="token comment">// "Did she say 'Hello'?"</span><span class="token string">"Did she say \"Hello\"?"</span><span class="token comment">// "Did she say "Hello"?"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        默认只能写在一行内，分成多行将会报错。</p><p>​        如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p><pre class="line-numbers language-none"><code class="language-none">var longString = 'Long \long \long \string';longString// "Long long long string"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连接运算符（<code>+</code>）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p><pre class="line-numbers language-none"><code class="language-none">var longString = 'Long '  + 'long '  + 'long '  + 'string';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p><pre class="line-numbers language-none"><code class="language-none">(function () { /*line 1line 2line 3*/}).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子中，输出的字符串就是多行。</p><p>​        2.转义</p><p>​        反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p><p>需要用反斜杠转义的特殊字符，主要有下面这些。</p><ul><li><code>\0</code> ：null（<code>\u0000</code>）</li><li><code>\b</code> ：后退键（<code>\u0008</code>）</li><li><code>\f</code> ：换页符（<code>\u000C</code>）</li><li><code>\n</code> ：换行符（<code>\u000A</code>）</li><li><code>\r</code> ：回车键（<code>\u000D</code>）</li><li><code>\t</code> ：制表符（<code>\u0009</code>）</li><li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li><li><code>\'</code> ：单引号（<code>\u0027</code>）</li><li><code>\"</code> ：双引号（<code>\u0022</code>）</li><li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li></ul><p>上面这些字符前面加上反斜杠，都表示特殊含义。</p><p><code>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略</code>。</p><p>3.字符串与数组</p><p>​        字符串可以看成字符数组，因此可以使用数组的运算符号。</p><p>​        但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token keyword">delete</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>s <span class="token comment">// "hello"</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>s <span class="token comment">// "hello"</span>s<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'!'</span><span class="token punctuation">;</span>s <span class="token comment">// "hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    ### length属性</code></pre><p>​        属性返回字符串的长度，该属性也是无法改变的。</p><pre class="line-numbers language-none"><code class="language-none">var s = 'hello';s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p><h3 id="Base64转码"><a href="#Base64转码" class="headerlink" title="Base64转码"></a>Base64转码</h3><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p><p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p><p>JavaScript 原生提供两个 Base64 相关的方法。</p><ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul><pre class="line-numbers language-none"><code class="language-none">var string = 'Hello World!';btoa(string) // "SGVsbG8gV29ybGQh"atob('SGVsbG8gV29ybGQh') // "Hello World!"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p><pre class="line-numbers language-none"><code class="language-none">btoa('你好') // 报错<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><pre class="line-numbers language-none"><code class="language-none">function b64Encode(str) {  return btoa(encodeURIComponent(str));}function b64Decode(str) {  return decodeURIComponent(atob(str));}b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、对象"><a href="#七、对象" class="headerlink" title="七、对象"></a>七、对象</h2><pre><code>    ### 1.对象的表达</code></pre><p>​        对象(object)是JavaScript语言的核心概念，也是最重要的数据类型。</p><p>对象：就是一组“键值对”(key-value)的集合，无序的复合数据集合。</p><pre class="line-numbers language-none"><code class="language-none">var obj = {  foo: 'Hello',  bar: 'World'};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注1：因为是键值对，故所有的键名都是字符串(es6中加入了Symbol也可以作为键名)。</p><p>注2：如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p><p>注3：对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p><p>注4：如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p><pre><code>    ### 2.属性的操作</code></pre><p>​        读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p><pre class="line-numbers language-none"><code class="language-none">var foo = 'bar';var obj = {  foo: 1,  bar: 2};obj.foo  // 1obj[foo]  // 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注1：查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p><p>注2：<code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性。</p><p>注3：<code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p><p>注4：<code>for...in</code>循环用来遍历一个对象的全部属性。</p><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。</li></ul><h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><h3 id="1-函数的声明"><a href="#1-函数的声明" class="headerlink" title="1.函数的声明"></a>1.函数的声明</h3><p>1）function 命令</p><p>​        function 声明的代码区块就是一个函数。</p><pre class="line-numbers language-none"><code class="language-none">function print(s) {  console.log(s);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。</p><p>2）函数表达式</p><p>​        除了function还可以命令声明函数，还可以采用变量赋值的写法。</p><pre class="line-numbers language-none"><code class="language-none">var print = function(s) {  console.log(s);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断字符串包含方法</title>
      <link href="/2021/08/19/pan-duan-zi-fu-chuan-bao-han-fang-fa/"/>
      <url>/2021/08/19/pan-duan-zi-fu-chuan-bao-han-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="判断字符串包含方法"><a href="#判断字符串包含方法" class="headerlink" title="判断字符串包含方法"></a>判断字符串包含方法</h1><ul><li><p>indexOf（searchStr，formIndex）</p><p>对大小写敏感，若不存在则返回-1；</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> srt <span class="token operator">=</span> <span class="token string">'asd'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>match（regexp）</p><p>在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p><pre class="line-numbers language-none"><code class="language-none">var str = "123"var reg = RegExp(/3/);if(str.match(reg)){ //包含；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>serach(regexp)</p><p>search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。</p><p>类似于indexOf（）</p></li><li><p><strong>test()</strong></p><p>用于检索字符串中指定的值。返回 true 或 false。</p></li><li><p><strong>exec()</strong></p><p>用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p><pre class="line-numbers language-none"><code class="language-none">var str = "123"var reg = RegExp(/3/);if(reg.exec(str)){  //包含；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/18/hello-world/"/>
      <url>/2021/08/18/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="善于总结-方得长久"><a href="#善于总结-方得长久" class="headerlink" title="善于总结 方得长久"></a>善于总结 方得长久</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
